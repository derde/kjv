#! /bin/bash

# KJV bible by defailt
BIBLE=$(dirname $0)/kjv.txt

# Show colours in terminal mode, but not in pipe mode
if tty -s 0>&1 ; then
    COLOUR="--colour=always"
    CAT=
else
    COLOUR=""
    CAT=1
fi

case "$GREP_COLOURS" in
    *";ne"*) true ;; # whatever
    *) GREP_COLORS="$GREP_COLORS;ne" ; export GREP_COLORS ;;
esac

memory() {
    sed '
        s/ \([^0-9A-Za-z]*\)\([A-Za-z]\)[^ .;:,)?]*/\1\2/g;
                            s/\(:[0-9]\+\|[.;:,)?]\+\)/\1 /g;
        s/\([A-Za-z]\{16\}\)\([A-Za-z]\{16,\}\)/\1 \2/g;
        s/\([A-Za-z]\{14\}\)\([A-Za-z]\{14,\}\)/\1 \2/g;
        s/\([A-Za-z]\{12\}\)\([A-Za-z]\{12,\}\)/\1 \2/g;
        s/\([A-Za-z]\{10\}\)\([A-Za-z]\{10,\}\)/\1 \2/g;
        '
    # 1 leading punctuation plus word plus trailing punctuation
    # 2 replace space after punctuation
    # 3 long word to two shorter words
    # Does oddly on this ...
    # Mark 6:22 And when the daughter of the said Herodias came in, and danced, and pleased Herod and them that sat with him, the king said unto the damsel, Ask of me whatsoever thou wilt, and I will give it thee.
}

# Do word-wrap because less cannot
splitlines() {
    if [ "$SPLITLINES" ] ; then
        WIDTH=$( stty -a </dev/tty | grep -Po 'columns \d+' | grep -Po '\d+' )
        perl -pe '
            sub esclen($) {
                my ($str) = @_;
                $str =~ s/[\[\]]//g;
                return length($str);
            }
            $width='$WIDTH'-1;
            $decision=$width-20;
            s/(([\[\]]*.[\[\]]*){$decision,$width})( |$)/$1.(" "x($width-esclen($1)+1))/eg ;
            s/  *$//; '; 
    else
        cat
    fi
}


# 
format() {
    # echo 1>&2 "mef $? $ITALICS $CAT"
    RSTRIP="sed 's/  *\$//'"
    if [ $CAT ] ; then
        eval "$RSTRIP $ITALICS $MOVEREFS $STRIPREFS $MEMORY"
    else
        # pipe the output to a browser
        WIDTH=$( stty -a </dev/tty | grep -Po 'columns \d+' | grep -Po '\d+' )
        eval "$RSTRIP $DOUBLELINE $MOVEREFS $STRIPREFS $SPLITLINES $ITALICS $MEMORY" |
        grep $GREPOPTS $COLOUR "$COLOURREGEX" |
        GREP_COLORS="ms=32:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36:ne" grep $COLOUR -P "$VERSEREF_RE" |
        $PAGER
    fi
}

striprefs() {
    sed 's/^[^:]*:[^ ]* //'
}
moverefs() {
    sed 's/\(^[^:]*:[^ ]*\) \(.*\)/\2 (\1)/'
}
doubleline() {
    sed 's/$/\n/'
}

italics_sed() {
  ESC=$'\e' 
  sed "s:\[:$ESC[1m:g; s:\]:$ESC[0m:g" 
}

italics_strip() {
  tr -d '[]'
}

italics_utf8() {
python <( cat << \EOF
# -*- coding: utf-8 -*-
latin = 'a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'.split()
italic = '𝑎 𝑏 𝑐 𝑑 𝑒 𝑓 𝑔 ℎ 𝑖 𝑗 𝑘 𝑙 𝑚 𝑛 𝑜 𝑝 𝑞 𝑟 𝑠 𝑡 𝑢 𝑣 𝑤 𝑥 𝑦 𝑧 𝐴 𝐵 𝐶 𝐷 𝐸 𝐹 𝐺 𝐻 𝐼 𝐽 𝐾 𝐿 𝑀 𝑁 𝑂 𝑃 𝑄 𝑅 𝑆 𝑇 𝑈 𝑉 𝑊 𝑋 𝑌 𝑍'.split()
import sys,re
def utf_italicise(m):
  o=[]
  for c in m.group(1):
    try:
      o.append(italic[latin.index(c)])
    except:
      o.append(c)
  return ''.join(o)
brackets_re=re.compile(r'\[(.*?)\]');
for line in sys.stdin:
  sys.stdout.write(brackets_re.sub(utf_italicise,line))
EOF
)
}

###########
GREPOPTS='-Pi'
BEGIN='\b'
CONTEXT='-C 5'
SPLITLINES=
STRIPREFS=
MOVEREFS=
PAGER='less -ifR'
DOUBLELINE=
ITALICS="|italics_sed"
tty -s 2>&0 || ITALICS="|italics_strip"
VERSEREF_RE='^.*\d+:\d+|$'  # green verse at the beginning of the line

parseopt() {
    case "$OPTIONCHAR" in
        i) BIBLE=$OPTARG ; BEGIN= ;;
        0) CONTEXT="" ;;
        [1-9]) CONTEXT="-C $OPTIONCHAR" ;;
        a) BIBLE=$(dirname $0)/af1953.txt ; SPLITLINES= ;;
        d) DOUBLELINE='|doubleline' ;;
        t) BIBLE=$(dirname $0)/tr1550.txt ; SPLITLINES= ; BEGIN= ;;  # UTF-8 splitting doesn't work well
        w) GREPOPTS="${GREPOPTS}w" ;;
        s) SPLITLINES="|splitlines" ;;
        r) STRIPREFS="|striprefs" ; COLOURREGEX='$' ;;
        R) STRIPREFS="|striprefs" ; CONTEXT=""; COLOURREGEX='$' ; PAGER=cat ; COLOUR_HIGHLIGHT='' ;;
        b) MOVEREFS="|moverefs"; VERSEREF_RE='\(.*?\d+:\d+\)|$' ;;
        p) BEGIN='' ;;
        o) ITALICS="|italics_strip"; PAGER=cat ;;
        m) ITALICS="|italics_strip"; MEMORY="|memory"  ;;
        *)
            echo "Usage: [$0] [options] [search words] ..."
            echo ""
            echo "  -r  omit verse references"
            echo "  -R  ONLY verse references"
            echo "  -b  put the references (at the back)"
            echo "  -w  word search"
            echo "  -m  memory version"
            echo "  -s  word-wrap to terminal size (automatic if output to terminal)"
            echo "  -p  partial word match (don't search word in any part of a word)"
            echo "  -0  zero verses context during search"
            echo "  -1 .. -9  more verses context"
            echo "  -t  use tr1550 greek text"
            echo "  -a  use af1953 afrikaans text"
            echo "  -o  don't pipe to less, just to stdout"
            echo "  -d  double line spacing"
            echo "  -i [file] specify input file"
            echo ""
            echo "Shows extracts having all the terms in the adjoining context"
            echo "With no options, display the text with highlighted verses using less"
            echo ""
            echo "   kjv"
            echo "   kjv liberty spy"
            echo "   kjv -t Matthew"
            exit 1
            ;;
    esac
}

while getopts "i:Rostpawbrd0123456789m" OPTIONCHAR ; do
    parseopt
done
shift $((OPTIND-1))

parseswitches() {
  SWITCHES="$1"
  SWITCHES="${SWITCHES:1}"
  while [ "$SWITCHES" ] ; do
    OPTIONCHAR=${SWITCHES:0:1}
    parseopt 
    SWITCHES="${SWITCHES:1}"
  done
}

####################################
COLOURREGEX='$'
if [ "$1" ] ; then
    # Late switches processing, Linux style:
    ARGS=""
    for ARG in "$@"; do
        case "$ARG" in
            -*) parseswitches "$ARG" ;;
            *) ARGS="$ARGS $ARG" ;;
        esac
    done
    EVALS=''
    for REGEX in "$@"; do
        case "$REGEX" in
          -*) true ;;
          *)
            EVALS="$EVALS | grep $GREPOPTS $CONTEXT '$BEGIN$REGEX' "
            COLOURREGEX="$BEGIN$REGEX|$COLOURREGEX"
            ;;
        esac
    done
    EVALS="tr -d $'\r' < $BIBLE $EVALS"
    #echo 1>&2 "$EVALS"
    eval "$EVALS" | format
elif tty -s ; then
    # Remove linefeeds and display in less
    tr -d $'\r' < $BIBLE | format
else
    # Just remove linefeeds and pipe to stdout
    tr -d '[]'$'\r' < $BIBLE
fi 

